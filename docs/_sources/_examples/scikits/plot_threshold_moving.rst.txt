
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_examples\scikits\plot_threshold_moving.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download__examples_scikits_plot_threshold_moving.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__examples_scikits_plot_threshold_moving.py:


06. Threshold moving approaches
-------------------------------

 .. note::  https://en.wikipedia.org/wiki/Sensitivity_and_specificity

.. GENERATED FROM PYTHON SOURCE LINES 7-296



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /_examples/scikits/images/sphx_glr_plot_threshold_moving_001.png
         :alt: plot threshold moving
         :srcset: /_examples/scikits/images/sphx_glr_plot_threshold_moving_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /_examples/scikits/images/sphx_glr_plot_threshold_moving_002.png
         :alt: plot threshold moving
         :srcset: /_examples/scikits/images/sphx_glr_plot_threshold_moving_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /_examples/scikits/images/sphx_glr_plot_threshold_moving_003.png
         :alt: From 'roc_curve', th=0.04, npv=0.093, ppv=0.966
         :srcset: /_examples/scikits/images/sphx_glr_plot_threshold_moving_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /_examples/scikits/images/sphx_glr_plot_threshold_moving_004.png
         :alt: From 'manual thresholds', th=0.495, npv=0.8, ppv=0.406
         :srcset: /_examples/scikits/images/sphx_glr_plot_threshold_moving_004.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none



    Results from 'roc_curve'
           th       ppv       npv      sens      spec     gmean
    69  0.000  0.951872       NaN  1.000000  0.000000  0.000000
    68  0.010  0.961945  0.085375  0.795455  0.377622  0.256511
    67  0.015  0.962139  0.081454  0.772727  0.398601  0.296193
    66  0.020  0.963411  0.085375  0.772727  0.419580  0.295118
    65  0.030  0.963836  0.086675  0.772727  0.426573  0.292956
    ..    ...       ...       ...       ...       ...       ...
    4   0.970  0.969824  0.049887  0.090909  0.944056  0.574130
    3   0.980  0.977196  0.050589  0.090909  0.958042  0.569404
    2   0.990  0.980924  0.050939  0.090909  0.965035  0.554987
    1   1.000  0.974726  0.049759  0.068182  0.965035  0.548071
    0     inf       NaN  0.048128  0.000000  1.000000  0.000000

    [70 rows x 6 columns]


    Results from manual
              th       ppv       npv      sens      spec
    0   0.000000  0.282258  0.857143  0.795455  0.377622
    1   0.010101  0.283333  0.850746  0.772727  0.398601
    2   0.020202  0.293103  0.859155  0.772727  0.426573
    3   0.030303  0.303571  0.866667  0.772727  0.454545
    4   0.040404  0.305556  0.860759  0.750000  0.475524
    ..       ...       ...       ...       ...       ...
    95  0.959596  0.333333  0.771429  0.090909  0.944056
    96  0.969697  0.333333  0.771429  0.090909  0.944056
    97  0.979798  0.400000  0.774011  0.090909  0.958042
    98  0.989899  0.444444  0.775281  0.090909  0.965035
    99  1.000000       NaN  0.764706  0.000000  1.000000

    [100 rows x 5 columns]






|

.. code-block:: default
   :lineno-start: 8


    # Libraries
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt

    # Libraries scikits
    from sklearn.datasets import fetch_openml
    from sklearn.datasets import load_iris
    from sklearn.datasets import load_breast_cancer
    from sklearn.preprocessing import StandardScaler
    from sklearn.pipeline import make_pipeline
    from sklearn.linear_model import LogisticRegression
    from sklearn.ensemble import ExtraTreesClassifier
    from sklearn.model_selection import train_test_split


    def display_npv_ppv_curve(ppv, npv, ths, idx):
        """This method plots the curve

        Parameters
        ----------
        ppv: array-like
        npv: array-like
        ths: array-like
        idx: integer
        """
        # Display
        f, axes = plt.subplots(1, 1)
        axes.plot(ths, npv, marker='o', label='npv')
        axes.plot(ths, ppv, marker='o', label='ppv')
        axes.set(aspect='equal', xlim=[0,1], ylim=[0,1],
            xlabel='threshold', title='th={0}, npv={1}, ppv={2}' \
                .format(round(ths[idx], 3),
                        round(npv[idx], 3),
                        round(ppv[idx], 3)))
        plt.legend()


    def npv_ppv_from_sens_spec(sens, spec, prev):
        """Compute npv and ppv.

        Parameters
        ----------
        sens: array-like
        spec: array-like
        prev: float
        """
        npv = (spec * (1 - prev)) / ((spec * (1 - prev)) + ((1 - sens) * prev))
        ppv = (sens * prev) / ((sens * prev) + ((1 - spec) * (1 - prev)))
        return npv, ppv



    # ----------------------
    # Load data
    # ----------------------
    # Fetch data
    X, y = fetch_openml(data_id=1464,
                        return_X_y=True,
                        as_frame=True)
                        #parser='auto')

    # Format y to binary (0,1)
    y = y.cat.rename_categories({'1':0, '2':1})


    # Split
    X_train, X_test, y_train, y_test = \
        train_test_split(X, y, stratify=y)

    # ----------------------
    # Create pipeline
    # ----------------------
    # Create pipeline
    clf = make_pipeline(
        StandardScaler(),
        #LogisticRegression(random_state=0)
        ExtraTreesClassifier(n_estimators=100)
    )

    # Train
    clf.fit(X_train, y_train)

    # Predictions
    y_pred = clf.predict(X_test)
    y_prob = clf.predict_proba(X_test)

    # .. note: Some classifiers do not have the decision
    #          function method but all implement the
    #          predict_proba.
    #y_score = clf.decision_function(X_test)

    # -----------------------
    # Show confusion matrix
    # -----------------------
    # .. note: We are using Display objects to plot
    #          the graphs, they could also be displayed
    #          using the functions or matplotlib
    #          directly.
    #
    # plot_roc_curve(clf, X_test, y_test, ax=ax_roc, name=name)
    # plot_det_curve(clf, X_test, y_test, ax=ax_roc, name=name)

    # Libraries
    from sklearn.metrics import confusion_matrix
    from sklearn.metrics import ConfusionMatrixDisplay
    from sklearn.metrics import roc_curve
    from sklearn.metrics import RocCurveDisplay
    from sklearn.metrics import precision_recall_curve
    from sklearn.metrics import PrecisionRecallDisplay

    # Value counts
    value_counts = y.value_counts()

    # Prevalence
    prev = value_counts[1] / len(y_test)

    # Confusion matrix
    cm = confusion_matrix(y_test, y_pred)

    # .. note: It is possible to use either y_score
    #          or y_prob in the roc_curve function
    # .. note: sens=tpr, spec=1-fpr
    # Compute ROC curve
    fpr, tpr, ths1 = roc_curve(
        y_test, y_prob[:, 1],
        drop_intermediate=False)

    # .. note: ppv=prec, sens=recall
    # Compute PR curve
    prec, recall, ths2 = \
        precision_recall_curve(y_test, y_prob[:, 1])

    # Create plot objects
    cm_display = ConfusionMatrixDisplay(cm)
    roc_display = RocCurveDisplay(fpr=fpr, tpr=tpr)
    pr_display = PrecisionRecallDisplay(precision=prec, recall=recall)

    # Create figure
    f, axes = plt.subplots(1, 2, figsize=(12, 4))
    axes = axes.flatten()

    # Display
    cm_display.plot()
    roc_display.plot(ax=axes[0])
    pr_display.plot(ax=axes[1])

    # Configure
    for ax in axes:
        ax.set(aspect='equal', xlim=[0,1], ylim=[0,1])
    plt.tight_layout()



    # ---------
    # Option I
    # ---------
    # Compute the npv and ppv from the sensitivity
    # and specificity values obtained from the
    # 'roc_curve' function.

    # Compute ROC curve
    fpr, tpr, ths1 = roc_curve(
        y_test, y_prob[:, 1],
        drop_intermediate=False)

    # Compute npv and ppv
    npv, ppv = npv_ppv_from_sens_spec( \
        sens=tpr, spec=1-fpr, prev=prev)

    # Create DataFrame
    results = pd.DataFrame(
        data=np.array([ths1, ppv, npv, tpr, 1-fpr]).T,
        columns=['th', 'ppv', 'npv', 'sens', 'spec']
    ).sort_values(by='th')

    # Add gmean
    results['gmean'] = np.sqrt(tpr * (1-fpr))

    # Find closest to 0.8
    idx = np.nanargmin(np.abs(npv - 0.8))

    # Find best gmean
    idx2 = np.argmax(results.gmean)

    # Display
    display_npv_ppv_curve(ppv, npv, ths1, idx)

    # Title
    plt.suptitle("From 'roc_curve'")

    # Show
    print("\n\nResults from 'roc_curve'")
    print(results)

    """
    # ---------
    # Option II
    # ---------
    # NOT WORKING!
    #
    # Compute the npv by knowing that it is the inverse
    # of the precision, thus calling the function
    # 'precision_recall_curve' with opposite labels and
    # probabilities.

    # .. note: invprec=npv
    # .. note: invrec=fnr
    # Computed inverted PR curve
    invprec, invrec, invths2 = \
        precision_recall_curve(y_test, y_prob[:, 0],
            pos_label=clf.classes_[0])

    # Create DataFrame
    results = pd.DataFrame()
    results['th'] = invths2[::-1]
    results['npv'] = invprec[1:]
    results['ppv'] = 0.0
    results = results.sort_values(by='th')

    # Find closest to 0.8
    idx = np.nanargmin(np.abs(invprec - 0.8))

    # Show
    print("\n\nResults from 'precision_recall_curve'")
    print(results)
    print("\nIndex: {0} | Threshold: {1} | NPV: {2}" \
        .format(idx, invths2[idx-1], npv[idx]))

    # Display graph
    display_npv_ppv_curve(
        results.ppv,
        results.npv,
        results.th,
        idx)

    # Title
    plt.suptitle("From 'precision_recall_curve'")
    """

    # ----------
    # Option II
    # ----------
    # Perform the computation of metrics and the threshold
    # search based on a condition (e.g. npv closest to an
    # specific value) manually.
    # Thresholds
    thresholds = np.linspace(0,1,100)

    # Metrics
    def metrics(y_test, y_prob, th, **kwargs):
        # Libraries
        from sklearn.metrics import confusion_matrix
        # Compute confusion matrix
        cm = confusion_matrix(y_test, y_prob>th)
        tn, fp, fn, tp = cm.ravel()
        # Compute metrics
        return {'th': th,
                'ppv': tp/(tp+fp),
                'npv': tn/(tn+fn),
                'sens': tp/(tp+fn),
                'spec': tn/(tn+fp)}

    # Compute scores
    scores = [metrics(y_test, y_prob[:,1], t) \
        for t in thresholds]

    # Create DataFrame
    results = pd.DataFrame(scores)

    # Find idx where npv is closest to 0.8
    idx = np.nanargmin(np.abs(results.npv - 0.8))

    # Show
    print("\n\nResults from manual")
    print(results)

    # Display graph
    display_npv_ppv_curve(
        results.ppv,
        results.npv,
        results.th,
        idx)

    # Title
    plt.suptitle("From 'manual thresholds'")

    # Show
    plt.show()

.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.506 seconds)


.. _sphx_glr_download__examples_scikits_plot_threshold_moving.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_threshold_moving.py <plot_threshold_moving.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_threshold_moving.ipynb <plot_threshold_moving.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
